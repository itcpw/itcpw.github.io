<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CentOS7.5安装nginx]]></title>
    <url>%2F2019%2F04%2F14%2FCentOS7.5%E5%AE%89%E8%A3%85nginx%2F</url>
    <content type="text"><![CDATA[Nginx 安装-系统平台：CentOS7.5 64位一.安装编译工具及库文件1yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 二.首先要安装 PCREPCRE 作用是让 Nginx 支持 Rewrite 功能。 下载 PCRE 安装包，下载地址： http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz 12[root@instance src]# cd /usr/local/src/[root@instance src]# wget http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz 解压安装包: 1[root@instance src]# tar zxvf pcre-8.35.tar.gz 进入安装包目录 1[root@instance src]# cd pcre-8.35 编译安装 12[root@instance pcre-8.35]# ./configure[root@instance pcre-8.35]# make &amp;&amp; make install 查看pcre版本 1[root@instance pcre-8.35]# pcre-config --version 三.安装 Nginx 下载 Nginx，下载地址：http://nginx.org/download/nginx-1.6.2.tar.gz 12[root@instance src]# cd /usr/local/src/[root@instance src]# wget http://nginx.org/download/nginx-1.6.2.tar.gz 解压安装包 1[root@instance src]# tar zxvf nginx-1.6.2.tar.gz 进入安装包目录 1[root@instance src]# cd nginx-1.6.2 使用 configure 命令创建一 makeFile 文件。 123456789101112131415./configure \--prefix=/usr/local/nginx \--pid-path=/var/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--with-http_gzip_static_module \--http-client-body-temp-path=/var/temp/nginx/client \--http-proxy-temp-path=/var/temp/nginx/proxy \--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \--http-scgi-temp-path=/var/temp/nginx/scgi//安装fastdfs-nginx-module是添加这个模块重新编译--add-module= /usr/local/fastdfs-nginx-module/src ---这个是根据解压后文件夹路径来的 执行后可以在nginx-1.6.2文件夹看到Makefile文件 Makefile是一种配置文件， Makefile 一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。 configure参数详解 1234567891011121314151617181920./configure \--prefix=/usr \ 指向安装目录--sbin-path=/usr/sbin/nginx \ 指向（执行）程序文件（nginx）--conf-path=/etc/nginx/nginx.conf \ 指向配置文件--error-log-path=/var/log/nginx/error.log \ 指向log--http-log-path=/var/log/nginx/access.log \ 指向http-log--pid-path=/var/run/nginx/nginx.pid \ 指向pid--lock-path=/var/lock/nginx.lock \ (安装文件锁定，防止安装文件被别人利用，或自己误操作.)--user=nginx \--group=nginx \--with-http_ssl_module \ 启用ngx_http_ssl_module支持（使支持https请求，需已安装openssl）--with-http_flv_module \ 启用ngx_http_flv_module支持（提供寻求内存使用基于时间的偏移量文件）--with-http_stub_status_module \ 启用ngx_http_stub_status_module支持（获取nginx自上次启动以来的工作状态）--with-http_gzip_static_module \ 启用ngx_http_gzip_static_module支持（在线实时压缩输出数据流）--http-client-body-temp-path=/var/tmp/nginx/client/ \ 设定http客户端请求临时文件路径--http-proxy-temp-path=/var/tmp/nginx/proxy/ \ 设定http代理临时文件路径--http-fastcgi-temp-path=/var/tmp/nginx/fcgi/ \ 设定http fastcgi临时文件路径--http-uwsgi-temp-path=/var/tmp/nginx/uwsgi \ 设定http uwsgi临时文件路径--http-scgi-temp-path=/var/tmp/nginx/scgi \ 设定http scgi临时文件路径--with-pcre 启用pcre库 编译 1make 第五步：安装 1make install 四.Nginx启动与访问 注意：启动nginx 之前，上边将临时文件目录指定为/var/temp/nginx/client， 需要在/var 下创建此 目录 1mkdir /var/temp/nginx/client -p 进入到Nginx目录下的sbin目录 1cd /usr/local/ngiux/sbin 输入命令启动Nginx 1./nginx 启动后查看进程 1ps aux|grep nginx 地址栏输入虚拟机的IP即可访问（默认为80端口） 关闭 nginx： 1./nginx -s stop 刷新配置文件： 1./nginx -s reload]]></content>
      <tags>
        <tag>安装nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7.5安装jdk1.8]]></title>
    <url>%2F2019%2F04%2F14%2FCentOS7.5%E5%AE%89%E8%A3%85jdk1.8%2F</url>
    <content type="text"><![CDATA[先卸载open-jdk(如果有的话,我的CentOS7.5没有)12345java –versionrpm -qa | grep javarpm -e --nodeps java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.x86_64rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.x86_64 开始安装： 新建文件夹,上传jdk压缩包 12mkdir /usr/local/javarz 上传jdk tar包 把压缩文件移动到新建文件夹 1tar -xvf jdk-8u202-linux-x64.tar.gz 配置环境变量： 配置环境变量 1vim /etc/profile 在末尾行添加 12345#set java environmentJAVA_HOME=/usr/local/java/jdk1.8.0_202CLASSPATH=.:$JAVA_HOME/lib.tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASSPATH PATH 保存退出 12- source /etc/profile 使更改的配置立即生效- java -version 查看JDK版本信息，如果显示出1.8.0证明成功]]></content>
      <tags>
        <tag>安装jdk1.8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7.5安装jdk1.8]]></title>
    <url>%2F2019%2F04%2F14%2FCentOs7.5%E5%AE%89%E8%A3%85fastDFS%2F</url>
    <content type="text"><![CDATA[下载压缩包 tracker和storage使用相同的安装包，下载地址：http://sourceforge.net/projects/FastDFS/ 或 https://github.com/happyfish100/FastDFS（推荐）本教程下载：FastDFS_v5.05.tar.gz FastDFS安装环境 FastDFS是C语言开发，建议在linux上运行，本教程使用Centos6.4作为安装环境。安装FastDFS需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc： 1yum install gcc-c++ 安装libevent FastDFS依赖libevent库，需要安装： 1yum -y install libevent 安装libfastcommon libfastcommon是FastDFS官方提供的，libfastcommon包含了FastDFS运行所需要的一些基础库。 将libfastcommonV1.0.7.tar.gz拷贝至/usr/local/下 12345cd /usr/localtar -zxvf libfastcommonV1.0.7.tar.gzcd libfastcommon-1.0.7./make.sh./make.sh install 注意：libfastcommon安装好后会自动将库文件拷贝至/usr/lib64下，由于FastDFS程序引用usr/lib目录所以需要将/usr/lib64下的库文件拷贝至/usr/lib下。要拷贝的文件如下：libfastcommon.so tracker编译安装 安装tracker和storage其实是安装fastdfs然后修改tracker或storage的配置文件 将FastDFS_v5.05.tar.gz拷贝至/usr/local/下 1234tar -zxvf FastDFS_v5.05.tar.gzcd FastDFS./make.sh./make.sh install 安装成功将安装目录下的conf下的文件拷贝到/etc/fdfs/下 1cp /usr/local/FastDFS/conf/* /etc/fdfs/ 配置进入/etc/fdfs目录： 123vim tracker.confvi tracker.confbase_path=/home/yuqing/fastdfs 改为： 1base_path=/home/fastdfs 创建fastdfs目录—————–很重要，没有这个文件夹启动不了 1mkdir /home/fastdfs 启动tracker 1/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart 设置开机自动启动 12[root@instance FastDFS]# vim /etc/rc.d/rc.local将运行命令行添加进文件：/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart FastDFS–storage安装 原理同trackerd,由于我是把trackerd和storage安装在一个服务器,所以只要安装一次FastDFS,然后修改/etc/fdfs下的storage.conf配置文件即可 修改storage.conf 1234567891011vi storage.confgroup_name=group1base_path=/home/yuqing/FastDFS改为：base_path=/home/FastDFSstore_path0=/home/yuqing/FastDFS改为：store_path0=/home/FastDFS/fdfs_storagemkdir /home/FastDFS/fdfs_storage这一步很关键，没有这个文件夹启动不了#如果有多个挂载磁盘则定义多个store_path，如下#store_path1=.....#store_path2=......tracker_server=192.168.101.3:22122 #配置tracker服务器:IP#如果有多个则配置多个trackertracker_server=192.168.101.4:22122 启动 1/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart 设置开机自动启动 12[root@instance FastDFS]# vim /etc/rc.d/rc.local将运行命令行添加进文件：/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart 上传图片测试 通过fdfs_test程序FastDFS安装成功可通过/usr/bin/fdfs_test测试上传、下载等操作。 12345修改/etc/fdfs/client.confbase_path=/home/fastdfstracker_server=192.168.101.3:22122使用格式：/usr/bin/fdfs_test 客户端配置文件地址 upload 上传文件 比如将/home下的图片上传到FastDFS中： 12345/usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/tomcat.pnghttp://192.168.101.3/group1/M00/00/00/wKhlBVVY2M-AM_9DAAAT7-0xdqM485_big.png就是文件的下载路径。对应storage服务器上的/home/fastdfs/fdfs_storage/data/00/00/wKhlBVVY2M-AM_9DAAAT7-0xdqM485_big.png文件。 由于现在还没有和nginx整合无法使用http下载。 FastDFS和nginx整合 在Storage上安装nginx 安装FastDFS-nginx-module:将FastDFS-nginx-module_v1.16.tar.gz传至/usr/local/下 123cd /usr/localtar -zxvf FastDFS-nginx-module_v1.16.tar.gzcd FastDFS-nginx-module/src 修改config文件将/usr/local/路径改为/usr/—–三处必须都改才行，不然模块编译不进去nginx将FastDFS-nginx-module/src下的mod_FastDFS.conf拷贝至/etc/fdfs/下 1cp mod_FastDFS.conf /etc/fdfs/ 并修改mod_FastDFS.conf的内容： 123456vi /etc/fdfs/mod_FastDFS.confbase_path=/home/FastDFStracker_server=192.168.101.3:22122#tracker_server=192.168.101.4:22122（多个tracker配置多行）url_have_group_name=true #url中包含group名称store_path0=/home/FastDFS/fdfs_storage #指定文件存储路径 将libfdfsclient.so拷贝至/usr/lib下 1cp /usr/lib64/libfdfsclient.so /usr/lib/ 创建nginx/client目录 1mkdir -p /var/temp/nginx/client nginx安装 添加FastDFS-nginx-module模块 123456789101112131415./configure \--prefix=/usr/local/nginx \--pid-path=/var/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--with-http_gzip_static_module \--http-client-body-temp-path=/var/temp/nginx/client \--http-proxy-temp-path=/var/temp/nginx/proxy \--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \--http-scgi-temp-path=/var/temp/nginx/scgi//安装fastdfs-nginx-module是添加这个模块重新编译--add-module= /usr/local/fastdfs-nginx-module/src ---这个是根据解压后文件夹路径来的 安装 12makemake install 添加server: 修改nginx配置文件 1vim /usr/local/nginx/conf/nginx.conf 添加一个server 123456789server &#123; listen 80; server_name 192.168.0.4; location /group1/M00/&#123; root /home/FastDFS/fdfs_storage/data/; ngx_fastdfs_module; &#125;&#125; 说明：server_name指定本机iplocation /group1/M00/：group1为nginx 服务FastDFS的分组名称，M00是FastDFS自动生成编号，对应store_path0=/home/FastDFS/fdfs_storage，如果FastDFS定义store_path1，这里就是M01 测试:比如我上传的图片地址是:http://192.168.0.4/group1/M00/00/00/wKgABFyzBhKAGUs6AAA-6HwHHTw944_big.png我的服务器公网ip是:106.12.18.128,我的服务器inet对应的ip是192.168.0.4,这样我在浏览器地址输入http://106.12.27.128/group1/M00/00/00/wKgABFyzBhKAGUs6AAA-6HwHHTw944_big.png即可访问到图片]]></content>
      <tags>
        <tag>安装jdk1.8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7.5安装mysql]]></title>
    <url>%2F2019%2F04%2F14%2FCentOS7.5%E5%AE%89%E8%A3%85mysql%2F</url>
    <content type="text"><![CDATA[Linux平台上推荐使用RPM包来安装Mysql,MySQL AB提供了以下RPM包的下载地址： MySQL - MySQL服务器。你需要该选项，除非你只想连接运行在另一台机器上的MySQL服务器。 MySQL-client - MySQL 客户端程序，用于连接并操作Mysql服务器。 MySQL-devel - 库和包含文件，如果你想要编译其它MySQL客户端，例如Perl模块，则需要安装该RPM包。 MySQL-shared - 该软件包包含某些语言和应用程序需要动态装载的共享库(libmysqlclient.so*)，使用MySQL。 MySQL-bench - MySQL数据库服务器的基准和性能测试工具。 安装前 我们可以检测系统是否自带安装 MySQL: rpm -qa | grep mysql 如果你系统有安装，那可以选择进行卸载: 12rpm -e mysql // 普通删除模式rpm -e --nodeps mysql // 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除 安装 MySQL： 接下来我们在 Centos7 系统下使用 yum 命令安装 MySQL，需要注意的是 CentOS 7 版本中 MySQL数据库已从默认的程序列表中移除，所以在安装前我们需要先去官网下载 Yum 资源包，下载地址为：https://dev.mysql.com/downloads/repo/yum/ 1234wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum updateyum install mysql-server 权限设置： 1chown mysql:mysql -R /var/lib/mysql 初始化 MySQL： 1mysqld --initialize 启动 MySQL： 1systemctl start mysqld 查看 MySQL 运行状态： 1systemctl status mysqld 注意：如果我们是第一次启动 mysql 服务，mysql 服务器首先会进行初始化的配置。 验证 MySQL 安装 在成功安装 MySQL 后，一些基础表会表初始化，在服务器启动后，你可以通过简单的测试来验证 MySQL 是否工作正常。使用 mysqladmin 工具来获取服务器状态：使用 mysqladmin 命令俩检查服务器的版本, 在 linux 上该二进制文件位于 /usr/bin 目录，在 Windows 上该二进制文件位于C:\mysql\bin. 1[root@host]# mysqladmin --version linux上该命令将输出以下结果，该结果基于你的系统信息： 1mysqladmin Ver 8.42 Distrib 5.6.43, for Linux on x86_64 如果以上命令执行后未输入任何信息，说明你的Mysql未安装成功。 Mysql安装后需要做的 Mysql安装成功后，默认的root用户密码为空，你可以使用以下命令来创建root用户的密码： 1[root@host]# mysqladmin -u root password &quot;new_password&quot;; 现在你可以通过以下命令来连接到Mysql服务器： 12[root@host]# mysql -u root -pEnter password:******* 注意：在输入密码时，密码是不会显示了，你正确输入即可。 设置开机自启动12vim /etc/rc.local添加service mysqld start 远程连接 这里是用的navcat连接mysql 遇到个问题:Host ‘xxx’ is not allowed to connect to this MySQL server 这里原因是因为root用户没有开启远程登录的权限 我们给用户授权: 1grant all PRIVILEGES on test_db.* to root@&apos;192.168.1.101&apos; identified by &apos;123456&apos;; 执行了上面的语句后，再执行下面的语句，方可立即生效。 1flush privileges; 上面的语句表示将 test_db 数据库的所有权限授权给 root 这个用户，允许 root 用户在 192.168.1.101 这个 IP 进行远程登陆，并设置 root 用户的密码为 123456 。下面逐一分析所有的参数： all PRIVILEGES 表示赋予所有的权限给指定用户，这里也可以替换为赋予某一具体的权限，例如select,insert,update,delete,create,drop 等，具体权限间用“,”半角逗号分隔。 test_db. 表示上面的权限是针对于哪个表的，test_db指的是数据库，后面的 表示对于所有的表，由此可以推理出：对于全部数据库的全部表授权为“.”，对于某一数据库的全部表授权为“数据库名.*”，对于某一数据库的某一表授权为“数据库名.表名”。 root 表示你要给哪个用户授权，这个用户可以是存在的用户，也可以是不存在的用户。 192.168.1.101 表示允许远程连接的 IP 地址，如果想不限制链接的 IP 则设置为“%”即可。 123456 为用户的密码。]]></content>
      <tags>
        <tag>mysql安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识梳理]]></title>
    <url>%2F2019%2F04%2F08%2F%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[java基础 jvm 集合 多线程 数据库 mysql oracle linux前端技能 html+div+css bootstrap js+jQuery+vue.js web基础 web三大组件: servlet servlet里三个域对象:request,session,servletContext listener filter tomcat 必备框架 spring springmvc mybatis 分布式rpc远程调用框架 dubbo spring-cloud 中间件 zookeeper eureka activemq rabbitmq zeromq kafuka 分布式存储 mysql mongodb redis 云存储 nginx 反向代理 负载均衡 静态服务器 分布式解决方案 分布式事务 跨域解决方案 分布式配置中心 分布式锁 分布式日志收集 分布式任务调度 服务降级与限流]]></content>
      <tags>
        <tag>知识梳理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx学习笔记]]></title>
    <url>%2F2019%2F04%2F08%2FNginx%2F</url>
    <content type="text"><![CDATA[作用： 负载均衡—集群（减轻单台服务器压力） 反向代理： 不暴露真实IP地址， 使用Https防止抓包分析Http请求 搭建企业黑名单和白名单系统 模拟请求(csrf业务攻击),XSS,SQL注入 解决ddos(流量攻击)—让别人无法访问 CDN 虚拟服务器 静态服务器(动静分离) 解决跨域问题 优点:性能非常好,占内存小,轻量级服务器,抗住同时5万并发连接 用途:分布式,微服务,高并发,高可用,消息中间件 同类产品:lys(中国人写的),F5(硬件,不是主流),Haproxy windows安装nginx1.nginx默认端口80 配置反向代理服务器 单台服务器接受高并发情况下,会发生宕机,瘫痪 高并发解决方案:集群 集群产生的问题: 分布式job幂等性问题, 会话共享问题 分布式生成全局ID 生成订单ID时间戳,订单号怎么解决幂等性问题,提前生成好,存储在Redis中 分布式锁:多个JVM之间通信,同一时间只有一个JVM生成订单号 客户端发送请求—&gt;nginx反向代理服务器(负载均衡)–&gt;各种服务 搭建集群前先搭建反向代理 配置负载均衡: 提高网站吞吐量,算法:轮训(机器都相同时使用),IP绑定(一直访问固定一台服务器,会话共享),权重(比例分配,机器配置不同),默认是轮训机制 轮训配置: 1234upstream backserver&#123; server 192.168.25.128 ; server 192.168.25.129 ;&#125; 权重配置:多了个weight属性,按几个服务器weight的值做比例来的 1234upstream backserver&#123; server 192.168.25.128 weight=2; server 192.168.25.129 weight=1;&#125; ip绑定:客户端ip地址和服务器地址进行绑定,除非换一台电脑,不然一直访问绑定的ip 12345upstream backserver&#123; ip_hash; server 192.168.25.128 ; server 192.168.25.129 ;&#125; 服务器宕机容错机制(高可用) 一主一备或者多主多备 配置多台主机和备用机,同时配置多台nginx和和备用nginx, 服务器宕机,首先keepalived重启脚本重启服务器,如果不行,nginx通过配置会轮询到下一台服务器, nginx服务器宕机,就会启动高可用工具keepalive重启脚本,重启多次仍不行,会通知运维人员 发布新版本的时候,为什么服务器能访问?先给主机发布,再给备机发布 tomcat发版本的时候session怎么同步?存放在redis或者在数据库中 跨域问题:属于前端ajax访问请求域名与浏览器访问的域名地址不相同,存在跨域问题 解决: jsoup不支持post请求支持get httpClien进行内部转发 使用http响应头允许跨域设置 使用nginx搭建企业api接口网关 使用springcloudzuul接口网关 网关:拦截所有请求,进行分发使用nginx搭建企业api接口网关实现原理:域名相同,项目不同,进行拦截跳转到真实服务器中 nginx如何实现高并发就是异步，非阻塞，使用了epoll和大量的底层代码优化。]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lucene]]></title>
    <url>%2F2018%2F03%2F20%2Flucene%2F</url>
    <content type="text"><![CDATA[全文检索：把文档分析之后，添加索引，查询索引的过程每个原始文档被分析为一个Document对象，一个Document对象含有多个域（field）,相当于数据库中的字段，如文档名，文档内容等；每个文档Ducument对象的相同域的内容放在一起，也就是说很多文档分析成几个域，相同类型的内容放在同一个域中，如”content”域中负责放文档内容，即关键字每个文档有一个唯一编号，即id 分析文档时，每个关键词都被封装成一个term对象，相当于一个键值对，键为域的名称，值为关键词.不同域中的相同关键词的term对象不相同 创建索引相当于给关键词列表添加一个域（field）即字段 什么是全文检索 数据的分类 结构化数据 格式固定、长度固定、数据类型固定。 例如数据库中的数据 非结构化数据 word文档、pdf文档、邮件、html、txt 格式不固定、长度不固定、数据类型不固定。 数据的查询 结构化数据的查询 SQL语句，查询结构化数据的方法。简单、速度快。 非结构化数据的查询 从文本文件中找出包含spring单词的文件。 目测 使用程序吧文档读取到内存中，然后匹配字符串。顺序扫描。 把非结构化数据变成结构化数据 先跟根据空格进行字符串拆分，得到一个单词列表，基于单词列表创建一个索引。 然后查询索引，根据单词和文档的对应关系找到文档列表。这个过程叫做全文检索。 索引：一个为了提高查询速度，创建某种数据结构的集合。 全文检索 先创建索引然后查询索引的过程叫做全文检索。 索引一次创建可以多次使用。表现为每次查询速度很快。 全文检索的应用场景 搜索引擎 百度、360搜索、谷歌、搜狗 站内搜索 论坛搜索、微博、文章搜索 电商搜索 淘宝搜索、京东搜索 只要是有搜索的地方就可以使用全文检索技术。 什么是Lucene Lucene是一个基于Java开发全文检索工具包。 Lucene实现全文检索的流程 创建索引 获得文档 原始文档：要基于那些数据来进行搜索，那么这些数据就是原始文档。 搜索引擎：使用爬虫获得原始文档 站内搜索：数据库中的数据。 案例：直接使用io流读取磁盘上的文件。 构建文档对象 对应每个原始文档创建一个Document对象 每个document对象中包含多个域（field） 域中保存就是原始文档数据。域的名称 域的值 每个文档都有一个唯一的编号，就是文档id 分析文档 就是分词的过程 根据空格进行字符串拆分，得到一个单词列表 把单词统一转换成小写。 去除标点符号 去除停用词停用词：无意义的词每个关键词都封装成一个Term对象中。 Term中包含两部分内容：关键词所在的域 关键词本身 不同的域中拆分出来的相同的关键词是不同的Term。 创建索引 基于关键词列表创建一个索引。保存到索引库中。 索引库中： 索引 document对象 关键词和文档的对应关系 通过词语找文档，这种索引的结构叫倒排索引结构。 查询索引 用户查询接口 用户输入查询条件的地方 例如：百度的搜索框 把关键词封装成一个查询对象 要查询的域 要搜索的关键词 执行查询 根据要查询的关键词到对应的域上进行搜索。 找到关键词，根据关键词找到 对应的文档 渲染结果 根据文档的id找到文档对象 对关键词进行高亮显示 分页处理 最终展示给用户看。 入门程序 创建索引 环境： 需要下载Lucene http://lucene.apache.org/ 最低要求jdk1.8 工程搭建： 创建一个java工程 添加jar： lucene-analyzers-common-7.4.0.jar lucene-core-7.4.0.jar commons-io.jar 步骤： 创建一个Directory对象，指定索引库保存的位置。 基于Directory对象创建一个IndexWriter对象 读取磁盘上的文件，对应每个文件创建一个文档对象。 向文档对象中添加域 把文档对象写入索引库 关闭indexwriter对象 使用luke查看索引库中的内容 查询索引库 步骤： 创建一个Director对象，指定索引库的位置 创建一个IndexReader对象 创建一个IndexSearcher对象，构造方法中的参数indexReader对象。 创建一个Query对象，TermQuery 执行查询，得到一个TopDocs对象 取查询结果的总记录数 取文档列表 打印文档中的内容 关闭IndexReader对象 分析器 查看分析器的分析效果 使用Analyzer对象的tokenStream方法返回一个TokenStream对象。词对象中包含了最终分词结果。 实现步骤： 创建一个Analyzer对象，StandardAnalyzer对象 使用分析器对象的tokenStream方法获得一个TokenStream对象 向TokenStream对象中设置一个引用，相当于数一个指针 调用TokenStream对象的rest方法。如果不调用抛异常 使用while循环遍历TokenStream对象 关闭TokenStream对象 IKAnalyzer的使用方法 把IKAnalyzer的jar包添加到工程中 把配置文件和扩展词典添加到工程的classpath下 注意：扩展词典严禁使用windows记事本编辑保证扩展词典的编码格式是utf-8扩展词典：添加一些新词停用词词典：无意义的词或者是敏感词汇默认使用的是标准分析器StandardAnalyzer 索引库维护 添加文档 删除文档 删除全部 根据查询、关键词删除文档 修改文档 修改的原理是先删除后添加 索引库查询 使用Query的子类 TermQuery 根据关键词进行查询。 需要指定要查询的域及要查询的关键词 RangeQuery 范围查询 使用QueryPaser进行查询 可以对要查询的内容先分词，然后基于分词的结果进行查询。 添加一个jar包 lucene-queryparser-7.4.0.jar]]></content>
      <tags>
        <tag>lucene 全文搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java web中中文乱码问题]]></title>
    <url>%2F2018%2F02%2F12%2Fjava_web%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[tomcat-7.x中中文乱码问题 在tomcat-7.x中Servlet的service中post方法没有解决中文乱码问题（tomcat-8.x中解决了） String s=request.getParameter(&quot;xxx&quot;); String s2=new String(s.getBytes(&quot;iso-8859-1&quot;).&quot;utf8&quot;); 在servlet.xml中进行如下配置（此方法仅总结，未实践）： &lt;Connector port=&quot;8009&quot; enableLookups=&quot;false&quot;redirectPort=&quot;8443&quot; debug=&quot;0&quot; protocol=&quot;AJP/1.3&quot;URIEncoding=&quot;UTF-8&quot;/&gt; tomcat-8.x中中文乱码问题： request,即当从浏览器获取数据时，分为get请求和post，无论客户端是什么类型的数据，用request。getParameterxxx方法，返回值都为String类型的数据， request.setCharacterEncoding(&quot;utf8&quot;);注：tomcat7.x中post请求乱码问题未解决，get解决了，所以tom7中post请求仅使用这一行代码解决不了，要使用上面的方法 response,即从servlet给浏览器返回数据时： response.setContentType(&quot;text/html;charset=utf8&quot;); response.setContentType(&quot;text/html;charset=utf8&quot;);给浏览器传json数据时设置， 注：Tomcat7对URI默认编码是ISO-8859-1Tomcat8对URI默认编码是UTF-8]]></content>
      <tags>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven笔记]]></title>
    <url>%2F2017%2F12%2F06%2FMaven%2F</url>
    <content type="text"><![CDATA[Maven 开发 编译 测试 打包 部署常用指令123456mvn clean ---&gt;清除target目录mvn compile---&gt;src/main下的代码进行编译，放在target目录下mvn test ---&gt;src/main；src/test；下的代码进行编译，放在target目录下mvn package---&gt;src/main；src/test；下的代码进行编译，打war包；放在target目录下mvn install---&gt;src/main；src/test；下的代码进行编译，打war包；放在target目录下，并把包放在本地仓库mvn deploy ---&gt; java项目目录结构1234src/main/javasrc/main/resourcessrc/test/javasrc/test/resources javaWeb12345src/main/javasrc/main/resourcessrc/main/webappsrc/test/javasrc/test/resources pom.xml12345&lt;dependency&gt; &lt;groupId&gt;cn.itcast&lt;/groupId&gt;&lt;!--公司域名的倒序--&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;&lt;!--项目名称--&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;!--版本号--&gt;&lt;/dependency&gt;]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql学习笔记]]></title>
    <url>%2F2017%2F09%2F16%2Fmysql%2F</url>
    <content type="text"><![CDATA[常用命令： 启动mysql：net start mysql; 登录本机：mysql -u root -p; mysql -hip -uroot -proot; 创建： 创建数据库：create database db1; 创建数据库2：create database if not exists db2; `create database db3 character set gbk;` `create database if not exists db3 character set gbk;` 查询： 查询数据库：show databases; 查询某一数据库：show create database db1; 修改：修改数据库字符格式：alter database db1 character set gbk; 删除：drop database db1;drop database if exists db1; 使用数据库： 查询当前数据库名称：select database(); 选择数据库:use db1; 操作表： 查询数据库中所有表名称：show tables; 查询表结构：desc 表名；select * from 表名； 创建表： 123456789101112create table 表名( 列名1 数据类型1， 列名2 数据类型2)；create table student( id int, name varchar(32), age int, score double(4,1), birthday date, insert_time timestamp); 复制表：create table 表名 like 表名； 删除表：drop table 表名；drop table if exists 表名; 修改表： 1234567891011121314151617181920修改表名：alter table 旧表名 rename to 新表名;查看表的字符集：alter table 表名 character set 字符集名称；添加一列：alter table 表名 add 列名 数据类型；修改名称 类型：alter table 表名 change 列名 新列名 新数据类型；//改变新的一种类型的列alter table 表名 modify 列名 新数据类型；//只改变列的名称删除列：alter table 表名 drop 列名;添加数据：INSERT INTO student(id,NAME,age,score) VALUES(2015,&apos;tom&apos;,18,85.5);删除一行数据：DELETE FROM student WHERE id=2015;注意：全删数据：DELETE FROM student ;效率低，表头也删了truncate table 表名：删除表，并创建一模一样的空表；修改数据：UPDATE student SET age=22,score=80.5 WHERE id=2015;UPDATE student SET age=22；全部修改 查询数据 12345678910and or not is nullSELECT DISTINCT adress FROM student ;SELECT math,english ,math+IFNULL(english,0) AS 总分 FROM student;SELECT math 数学,english 英语,math+IFNULL(english,0) 总分 FROM student;SELECT * FROM student WHERE age IN(18,20,25);SELECT * FROM student WHERE age&gt;=20;SELECT * FROM student WHERE NAME LIKE &apos;麦%&apos;;SELECT * FROM student WHERE NAME LIKE &apos;_邦%&apos;;SELECT * FROM student WHERE NAME LIKE &apos;___&apos;;SELECT * FROM student WHERE NAME LIKE &apos;%冰%&apos;; DQL查询SELECT * FROM student ORDER BY math ASC，english DESC; 选择偶数行,奇数行: 12select * from where mod(id,2)=0;select * from where mod(id,2)=1; 聚合函数： 12345671、count: select count(math) from student; 选择非空的列进行计算 ifnull函数：SELECT COUNT(IFNULL(english,0)) FROM student;2、sum：SELECT SUM(english) FROM student;3、max：SELECT MAX(english) FROM student;4、min：5、avg： 分组查询： 123查询男女同学的数学平均分：SELECT sex,AVG(math) FROM student GROUP BY sex;SELECT sex,AVG(math) FROM student WHERE math&gt;70 GROUP BY sex;SELECT sex,AVG(math) FROM student WHERE math&gt;70 GROUP BY sex HAVING count(id)&gt;2; 分页查询： 12SELECT * FROM student LIMIT 0,3;开始的索引 = (当前的页码 - 1) * 每页显示的条数 Group By:从字面意义上理解就是根据“By”指定的规则对数据进行分组，所谓的分组就是将一个“数据集”划分成若干个“小区域”，然后针对若干个“小区域”进行数据处理。 约束： 非空约束(not null)： 123创建表时添加非空约束：CREATE TABLE student(id int,name varchar(20) NOT NULL);创建完添加非空约束：alert table student modify name varchar(20) not null;修改非空约束：alert table student modify name varchar(20); 唯一约束(unique)： 123创建表时添加唯一约束：CREATE TABLE student(id int,name varchar(20) unique);可以有null但也只能有一个删除唯一约束：alter table student drop index age;表创建完后添加唯一约束：alter table student modify age int unique; 主键约束(primary key)： 123456非空且唯一，一张表只有一个字段为主键，主键就是表中记录的唯一主键create table student(id int primary key,name varchar(32));删除主键约束：alter table student drop primary key;创建完表添加主键：alter table student modify id int primary key;如果某一列是数值类型的，使用 auto_increment可以来完成值的自动增长;删除自动增长：alter table student modify id int;添加自动增长：alter table student modify id int auto_increment; 外键约束(foreign key)： 12345678在创建表时，可以添加外键create table 表名( ... constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) );删除外键：alter table 表名 drop foreign key 外键名称添加外键：alter table 表名 add constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称);级联更新：删除外键以后再执行级联更新，alter table 表名 add constraint 外键名称 foreign key (外键列表名称) references 主表名称(主表列名称) on update cascade;级联删除：删除外键以后再执行级联更新，alter table 表名 add constraint 外键名称 foreign key (外键列表名称) references 主表名称(主表列名称) on update cascade on delete cascad； 数据库的设计： 多表之间的关系： 一对一： 一对多(多对一)：在多地一方建立外键，指向一的一方的主键 多对多：需要中间表，至少包含两个字段，这两个字段作为中间表的外键，分别指向两张表的主键 数据库备份还原：mysqldump -uroot -proot 数据库名&gt;保存路径 内连接查询：显式内连接： 关键字：inner join on 语句：select * from a_table a inner join b_table b on a.a_id = b.b_id; 组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集(阴影)部分。 隐式内链接：使用where条件消除无用数据，选择列时两个表同名的字段前要加表的名称 外连接查询：左外连接：左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录, select * from a_table a left join b_table b on a.a_id = b.b_id; 右外连接：与右外相反,select * from a_table a right outer join b_table b on a.a_id = b.b_id; 全外连接：(oracle特有) 子查询：查询中嵌套查询，称嵌套查询为子查询；结果是单行单列的：SELECT * FROM student WHERE s_id=(SELECT s_id FROM score WHERE s_score=99); 结果是多行单列的：SELECT * FROM student WHERE student.`s_id`IN(SELECT score.`s_id`FROM score WHERE score.`s_score`&gt;=90); 结果是多行多列的：子查询结果作为一张虚拟表； ##自连接：把一张表当多张表来用 —-&gt;用于属性菜单的表 ##事务： 开启事务，回滚，提交事务，同一事务的多个操作必须保证使用的同一个连接 四大特征：原子性，持久性，隔离性，一致性。 事务的隔离级别： read uncommited: 脏读 不可重复读 幻读 read commited: 不可重复读 幻读(oracle默认的隔离级别) repeatable read: 幻读(mysql默认的隔离级别) serializable: 都可以避免，效率最低 给两个有关联(外键)的表添加数据,先给主表添加才能给次表添加;要删除,得先删除次表数据,才能删除主表对应数据 mysql数据库在windows下字段名称(列名)不区分大小写 ##容易忽略的小点： jdbc是连接数据库的api, druid和c3p0是连接池技术 jdbctemplete和dbutils是操作数据库的工具类 jdbctemplete需要自己写个jdbcutils提供连接池;dbutils需要c3p0utils提供连接池 增删改一般都是单表的 where语句中不可以使用聚合函数 ##数据库优化 数据库设计要合理(三大范式) 添加索引(普通索引,主键索引,唯一索引,全文索引) 分表分库技术(去模分表,水平分割,垂直分割) 读写分离 存储过程 配置最大连接数my.ini 数据库服务器升级 随时清理碎片化 sql语句调优 ###数据库设计 1F.原子约束,每一列不能再分 2F.保证每一条记录唯一 3F.不要有冗余数据 ###分库与分表 垂直切分:把表按模块划分到不同的数据库中,但没有解决单表数据量大的问题 水平切分:把一个表按照某种规则吧数据划分到不同表或数据库中]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript笔记]]></title>
    <url>%2F2017%2F08%2F10%2FJavaScript%26JQuery%2F</url>
    <content type="text"><![CDATA[ECMA:基本类型(五种)：Number,String,Boolean,Null,Undefined BOM(Browser Object Model)Window对象:三个弹窗(alert,confirm,prompt)，四个计时(setInterval(函数名,毫秒值),clearInterval(计时对象),setTimeout,clearTimeout) Navigator对象：navigator.cookieEnabled 判断浏览器cookie是否可用 Location对象：location.reload location.href=&quot;&quot; var href=location.href; History对象：history.length,go(参数前进或后退几个页面),forword(),back() Screen对象： DOM(Document Object Model)元素节点： 属性节点： 内容节点： 添加/删除/获取属性：元素对象.setAttribute(&quot;属性名&quot;,&quot;属性值&quot;);元素对象.removeAttribute(&quot;属性名&quot;);元素对象.getAttribute(&quot;属性名&quot;);==元素对象.属性名(注意类名是用className); 获取元素：getElementById();getElementsByName();getElementsByClassName();getElementsByTagName(); 创建/添加/删除元素(标签)：document.createElement(&quot;标签名&quot;);父元素对象.appendChild(子元素对象名(注意不能加引号)); 父元素对象.removeChild(子元素对象名(注意不能加引号)); 获取父节点：子节点对象.parentNode; 创建文本节点：document.createTextNode(字符串); 元素对象.innerHTML;element.style.样式的属性名 = &quot;&quot;; Event事件：onclick ondblclick onfocus:获取焦点 onblur:失去焦点 onchange:可用于下拉选择框的select元素 onmouseover: onmouseout: onload: onkeyup: onsubmit:用于form元素，在该事件触发的函数中一定需要有return，true表示表单提交，false表示表单不提交，默认是true eg:&lt;form onsubmit= &quot;return fun();&quot;&gt;&lt;/form&gt; function fun(){ return true/false; } jQuery: jQuery与js对象之间的转化： jQuery对象转js对象：var jsObj=$(“”)[0];var jsObj=$(“”).get(0);转换只能是0，获取可以是其他值 js对象转jQuery对象：var jqObj=$(js对象名); jQuery获取节点对象： 标签选择 -var divs=$(“div”); id选择 -var box=$(“#box”); 类选择 -var demo=$(“.demo”); 属性选择 -var value=$(“input[value]”); var id=$(“div[id]”); 选择器 基本选择器 标签选择器（元素选择器） 语法： $(“html标签名”) 获得所有匹配标签名称的元素 id选择器 语法： $(“#id的属性值”) 获得与指定id属性值匹配的元素 类选择器 语法： $(“.class的属性值”) 获得与指定的class属性值匹配的元素 并集选择器： 语法： $(“选择器1,选择器2….”) 获取多个选择器选中的所有元素 层级选择器 后代选择器 语法： $(“A B “) 选择A元素内部的所有B元素，包括孙子，曾孙子中的B元素 子选择器 语法： $(“A &gt; B”) 选择A元素内部的所有B子元素(只包括子元素) 属性选择器 属性名称选择器 语法： $(“A[属性名]”) 包含指定属性的选择器 属性选择器 语法： $(“A[属性名=’值’]”) 包含指定属性等于指定值的选择器 复合属性选择器 语法： $(“A[属性名=’值’][]…”) 包含多个属性条件的选择器 过滤选择器(伪类选择器) 首元素选择器 语法： :first 获得选择的元素中的第一个元素 尾元素选择器 语法： :last 获得选择的元素中的最后一个元素 非元素选择器 语法： :not(selector) 不包括指定内容的元素 偶数选择器 语法： :even 偶数，从 0 开始计数 奇数选择器 语法： :odd 奇数，从 0 开始计数 等于索引选择器 语法： :eq(index) 指定索引元素 大于索引选择器 语法： :gt(index) 大于指定索引元素 小于索引选择器 语法： :lt(index) 小于指定索引元素 标题选择器 语法： :header 获得标题（h1~h6）元素，固定写法 表单过滤选择器 可用元素选择器 语法： :enabled 获得可用元素 不可用元素选择器 语法： :disabled 获得不可用元素 选中选择器 语法： :checked 获得单选/复选框选中的元素 选中选择器 语法： :selected 获得下拉框选中的元素绑定事件：节点对象.click(function(){});修改样式：节点对象.css(“属性名”,”属性值”);入口函数：$(function(){})与window.onload=function(){}不同的是，jq入口函数可以设置多个，且都会执行，而js的则只会执行最后一个js入口函数在页面所有资源加载完毕再执行，而jQuery则是在页面document树加载完成就执行jQuery入口函数比js入口函数先执行 DOM操作 内容操作 html(): 获取/设置元素的标签体内容 内容 –&gt; 内容 和.innerHTML效果一样，标签体内容 text(): 获取/设置元素的标签体纯文本内容 内容 –&gt; 内容 和.innerText效果一样 val()： 获取/设置元素的value属性值 属性操作 通用属性操作 attr(): 获取/设置元素的属性 removeAttr():删除属性 prop():获取/设置元素的属性 removeProp():删除属性 attr和prop区别？ 如果操作的是元素的固有属性，则建议使用prop 如果操作的是元素自定义的属性，则建议使用attr 对class属性操作 addClass():添加class属性值 removeClass():删除class属性值 toggleClass():切换class属性 toggleClass(“one”): 判断如果元素对象上存在class=”one”，则将属性值one删除掉。 如果元素对象上不存在class=”one”，则添加 css(): CRUD操作: append():父元素将子元素追加到末尾 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾对象1是被插入对象 prepend():父元素将子元素追加到开头 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 appendTo(): 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 对象2是被插入对象 prependTo()： 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 after():添加元素到元素后边 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系 before():添加元素到元素前边 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 insertAfter() 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系 insertBefore() 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 remove():移除元素 对象.remove():将对象自己删除掉 empty():清空元素的所有后代元素。 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点 获取元素(节点)对象：$(“标签选择器/类选择器/id选择器”)–类选择器和标签选择器得到的是一个数组，id选择器得到的是单个对象如果使用jQuery选择器获取的是多个元素组成的数组，但是数组中的每个元素都是js对象如果遍历这个数组，遍历出来的每个元素都是js对象，要使用jQuery方法，则要转换成为jQuery对象 Ajax Asynchronize javascript and xml异步非阻塞&lt;---&gt;同步阻塞 传递数据的载体： 文本：xmlhttp.responseText; XML:xmlhttp.responseXML;----可以看作是一种小型的数据库，存储万条内的数据 Json：文本; JSON：JavaScript Object Notation–&gt;javascript对象表示法 数据在名称/值对中 数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 文件的文件类型是 “.json” JSON 文本的 MIME 类型是 “application/json” JSON 最常见的用法之一，是从 web 服务器上读取 JSON 数据（作为文件或作为 HttpRequest），将 JSON 数据转换为 JavaScript 对象，然后在网页中使用该数据。 123456789JsonIgnoreProperties(&#123;&quot;&quot;,&quot;&quot;,...&#125;);JsonFormat(pattern=&quot;&quot;);JsonIgnore;mapper.setDateFormat(new SimpleDateFormat(&quot;&quot;));javaBean ---&gt;json mapper.writeValueAsString();json ---&gt;javaBeanjson ---&gt;javascript对象javascript对象---&gt;json {}大括号，表示定义一个对象，大部分情况下要有成对的属性和值，或是函数 .[]中括号，表示一个数组，也可以理解为一个数组对象 点击获取元素自身的方法： 1.在元素上加onclick=”fun(this)”;注意一定要加this; 2.function fun(obj){ var this_obj=$(obj); } 12345678910111213141516javascript实现动态展示分页if(data.data.currentPage&gt;data.data.totalPage-10)&#123;//当前页大于总页数-10时 end=data.data.totalPage; begin=end-10;&#125;else if(data.data.currentPage&lt;10)&#123;//当前页小于十页时 begin=1; end=begin+9;&#125;else &#123;//其他情况时 if(end-2&lt;data.data.currentPage)&#123;//当前页大于end-2; end=data.data.currentPage+2; begin=end-9; &#125;else if(data.data.currentPage&lt;begin+2)&#123;//当前小于begin+2; begin=data.data.currentPage-2; end=begin+9; &#125;&#125; jQuery-validate规则–表单验证插件 序号 规则 描述 required: true 必须输入的字段 remote: “check.php” 使用 ajax 方法调用 check.php 验证输入值 email: true 必须输入正确格式的电子邮件 url: true 必须输入正确格式的网址 date: true 必须输入正确格式的日期。日期校验 ie6 出错，慎用 dateISO: true 必须输入正确格式的日期（ISO），例如：2009-06-23，1998/01/22。只验证格式，不验证有效性 number: true 必须输入合法的数字（负数，小数） digits: true 必须输入整数 creditcard: 必须输入合法的信用卡号 equalTo: “#field” 输入值必须和 #field 相同 accept: 输入拥有合法后缀名的字符串（上传文件的后缀） maxlength: 5 输入长度最多是 5 的字符串（汉字算一个字符） minlength: 10 输入长度最小是 10 的字符串（汉字算一个字符） rangelength: 5,10] 输入长度必须介于 5 和 10 之间的字符串（汉字算一个字符） range: [5,10] 输入值必须介于 5 和 10 之间。 max: 5 输入值不能大于 5 min: 10 输入值不能小于 10]]></content>
      <tags>
        <tag>javascript jQuery</tag>
      </tags>
  </entry>
</search>
